                             Muldis::D::RefEng
                                   TODO
---------------------------------------------------------------------------

Following is a summary of things that still need doing.

* Never execute Muldis D stimulus response rules when compiling it unless
the user explicitly passed a flag saying it was ok, for security, they may
think it was just data by default.

* Only ship cross-compiled versions of standard Muldis D libraries with
Muldis::D::RefEng, eg as a set of files with names like
lib/Muldis/D/RefEng/Compiled/Muldis_D/http_muldis_com__0_120_0/Stringy.pm
for simplicity and performance.  The Muldis::D::RefEng::Compiled::*
namespace is where all user-written Muldis D code is compiled to anyway for
normal use.  Users can see Muldis-D-Standard distro for system lib sources.

* Make parser and compiler as simple as possible such that each one has
practically zero knowledge of runtime issues such as the routine dispatch
system.  Each Muldis D package becomes a Perl 5 package, 1:1, and every
Muldis D routine call is mediated by a runtime routine like
call_function(ident,args) so the compiled Muldis D code is isolated from
all that complexity.  Since most MD code goes through Low_Level to eg do
all the math or array stuff or whatever, there's no Perl equivalent
translation to worry about.  All binding between compiled packages is done
strictly at runtime and call_function(ident,args) is the thing savvy to it.
Actually it is resolve() or something that provides a set of 0..N candidates,
each a Reference, based just on the names, and call_function() then picks
one based on the argument data type.  Only 'search' can produce more than
one result, all others produce exactly one, which fails if it doesn't exist;
for relative and absolute we can know this at compile time, and search only
if the current package doesn't use any others, and identity only if pointing
to the current package.

* Write REPL in Muldis D itself, only ship first RE 0.x version when it
supports that.

* Figure out some way to be non-blocking / asynchronous / service-like
in the API, particularly between what are considered separate Muldis D VM
"processes" already, where one being busy doesn't block others.  See POE.

* In Low_Level, consider storing strings opt as arrays of Perl strings, for
performance/memory in the face of blobs, so catenation is lazier.
Inspiration to a point by Postgres' TOAST feature.

* Whatever else needs doing, such as, fixing bugs.
